// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEntry = `-- name: CreateEntry :one
INSERT INTO entries (
  user_id,
  title,
  body_delta,
  body_html,
  body_text,
  attendees_original,
  attendees,
  type,
  day_year,
  day_month,
  day_day
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
RETURNING id, user_id, title, body_delta, body_html, render_version, attendees_original, attendees, type, day_year, day_month, day_day, archived, created_at, updated_at, embedding_vector, vectors_updated_at, body_text
`

type CreateEntryParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	Title             string      `json:"title"`
	BodyDelta         []byte      `json:"body_delta"`
	BodyHtml          string      `json:"body_html"`
	BodyText          string      `json:"body_text"`
	AttendeesOriginal string      `json:"attendees_original"`
	Attendees         []string    `json:"attendees"`
	Type              string      `json:"type"`
	DayYear           int32       `json:"day_year"`
	DayMonth          int32       `json:"day_month"`
	DayDay            int32       `json:"day_day"`
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error) {
	row := q.db.QueryRow(ctx, createEntry,
		arg.UserID,
		arg.Title,
		arg.BodyDelta,
		arg.BodyHtml,
		arg.BodyText,
		arg.AttendeesOriginal,
		arg.Attendees,
		arg.Type,
		arg.DayYear,
		arg.DayMonth,
		arg.DayDay,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.BodyDelta,
		&i.BodyHtml,
		&i.RenderVersion,
		&i.AttendeesOriginal,
		&i.Attendees,
		&i.Type,
		&i.DayYear,
		&i.DayMonth,
		&i.DayDay,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingVector,
		&i.VectorsUpdatedAt,
		&i.BodyText,
	)
	return i, err
}

const getDaysWithEntries = `-- name: GetDaysWithEntries :many
SELECT DISTINCT day_year, day_month, day_day
FROM entries
WHERE user_id = $1
  AND day_year = $2
  AND day_month = $3
  AND archived = false
ORDER BY day_year, day_month, day_day
`

type GetDaysWithEntriesParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	DayYear  int32       `json:"day_year"`
	DayMonth int32       `json:"day_month"`
}

type GetDaysWithEntriesRow struct {
	DayYear  int32 `json:"day_year"`
	DayMonth int32 `json:"day_month"`
	DayDay   int32 `json:"day_day"`
}

func (q *Queries) GetDaysWithEntries(ctx context.Context, arg GetDaysWithEntriesParams) ([]GetDaysWithEntriesRow, error) {
	rows, err := q.db.Query(ctx, getDaysWithEntries, arg.UserID, arg.DayYear, arg.DayMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDaysWithEntriesRow
	for rows.Next() {
		var i GetDaysWithEntriesRow
		if err := rows.Scan(&i.DayYear, &i.DayMonth, &i.DayDay); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntry = `-- name: GetEntry :one
SELECT id, user_id, title, body_delta, body_html, render_version, attendees_original, attendees, type, day_year, day_month, day_day, archived, created_at, updated_at, embedding_vector, vectors_updated_at, body_text FROM entries
WHERE id = $1 AND archived = false LIMIT 1
`

func (q *Queries) GetEntry(ctx context.Context, id pgtype.UUID) (Entry, error) {
	row := q.db.QueryRow(ctx, getEntry, id)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.BodyDelta,
		&i.BodyHtml,
		&i.RenderVersion,
		&i.AttendeesOriginal,
		&i.Attendees,
		&i.Type,
		&i.DayYear,
		&i.DayMonth,
		&i.DayDay,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingVector,
		&i.VectorsUpdatedAt,
		&i.BodyText,
	)
	return i, err
}

const listAllEntries = `-- name: ListAllEntries :many
SELECT id, user_id, title, body_delta, body_html, render_version, attendees_original, attendees, type, day_year, day_month, day_day, archived, created_at, updated_at, embedding_vector, vectors_updated_at, body_text FROM entries
WHERE archived = false
ORDER BY day_year DESC, day_month DESC, day_day DESC, created_at ASC
`

func (q *Queries) ListAllEntries(ctx context.Context) ([]Entry, error) {
	rows, err := q.db.Query(ctx, listAllEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.BodyDelta,
			&i.BodyHtml,
			&i.RenderVersion,
			&i.AttendeesOriginal,
			&i.Attendees,
			&i.Type,
			&i.DayYear,
			&i.DayMonth,
			&i.DayDay,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingVector,
			&i.VectorsUpdatedAt,
			&i.BodyText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntriesForDay = `-- name: ListEntriesForDay :many
SELECT id, user_id, title, body_delta, body_html, render_version, attendees_original, attendees, type, day_year, day_month, day_day, archived, created_at, updated_at, embedding_vector, vectors_updated_at, body_text FROM entries
WHERE user_id = $1
  AND day_year = $2
  AND day_month = $3
  AND day_day = $4
  AND archived = false
ORDER BY created_at ASC
`

type ListEntriesForDayParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	DayYear  int32       `json:"day_year"`
	DayMonth int32       `json:"day_month"`
	DayDay   int32       `json:"day_day"`
}

func (q *Queries) ListEntriesForDay(ctx context.Context, arg ListEntriesForDayParams) ([]Entry, error) {
	rows, err := q.db.Query(ctx, listEntriesForDay,
		arg.UserID,
		arg.DayYear,
		arg.DayMonth,
		arg.DayDay,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entry
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.BodyDelta,
			&i.BodyHtml,
			&i.RenderVersion,
			&i.AttendeesOriginal,
			&i.Attendees,
			&i.Type,
			&i.DayYear,
			&i.DayMonth,
			&i.DayDay,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmbeddingVector,
			&i.VectorsUpdatedAt,
			&i.BodyText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEntry = `-- name: SoftDeleteEntry :exec
UPDATE entries
SET archived = true,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteEntry(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteEntry, id)
	return err
}

const updateEntry = `-- name: UpdateEntry :one
UPDATE entries
SET title = $2,
    body_delta = $3,
    body_html = $4,
    body_text = $5,
    attendees_original = $6,
    attendees = $7,
    type = $8,
    updated_at = NOW()
WHERE id = $1 AND archived = false
RETURNING id, user_id, title, body_delta, body_html, render_version, attendees_original, attendees, type, day_year, day_month, day_day, archived, created_at, updated_at, embedding_vector, vectors_updated_at, body_text
`

type UpdateEntryParams struct {
	ID                pgtype.UUID `json:"id"`
	Title             string      `json:"title"`
	BodyDelta         []byte      `json:"body_delta"`
	BodyHtml          string      `json:"body_html"`
	BodyText          string      `json:"body_text"`
	AttendeesOriginal string      `json:"attendees_original"`
	Attendees         []string    `json:"attendees"`
	Type              string      `json:"type"`
}

func (q *Queries) UpdateEntry(ctx context.Context, arg UpdateEntryParams) (Entry, error) {
	row := q.db.QueryRow(ctx, updateEntry,
		arg.ID,
		arg.Title,
		arg.BodyDelta,
		arg.BodyHtml,
		arg.BodyText,
		arg.AttendeesOriginal,
		arg.Attendees,
		arg.Type,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.BodyDelta,
		&i.BodyHtml,
		&i.RenderVersion,
		&i.AttendeesOriginal,
		&i.Attendees,
		&i.Type,
		&i.DayYear,
		&i.DayMonth,
		&i.DayDay,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmbeddingVector,
		&i.VectorsUpdatedAt,
		&i.BodyText,
	)
	return i, err
}
